[{"content":"Go Starter Go is a programming language designed for the open source community, it is supported by Google and has a simlar way of operating to C programming, it depends on its own environment variable system for most to all of its operations Go has a garbage collector which handles most memory errors effectively, it doesn\u0026rsquo;t have null based errors but rather handles them in a way which would be discussed in [Error Handling](#Error Handling) Now before we get started on the syntax of Go and how it differs from other programming languages lets look at how Go operates with its files\nInstalling and using Go The guides of downloading and installing the go compiler and its standard library and tools can be found here For linux systems, you can use your distributions package manager to install go, for example for debian and Arch distros Debian/Ubuntu 1 2 sudo apt update sudo apt install golang-go Arch Linux 1 sudo pacman -Sy go Go env, package and modules go env Go has a lot of go based environment variables to look through all of them, these only work within a go project and cannot be access in a bash environment directly, you can use the go env command to view all go environment variables Currently the environment variable within go are\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 $ go env GO111MODULE=\u0026#39;\u0026#39; GOARCH=\u0026#39;amd64\u0026#39; GOBIN=\u0026#39;\u0026#39; GOCACHE=\u0026#39;/home/user/.cache/go-build\u0026#39; GOENV=\u0026#39;/home/user/.config/go/env\u0026#39; GOEXE=\u0026#39;\u0026#39; GOEXPERIMENT=\u0026#39;\u0026#39; GOFLAGS=\u0026#39;\u0026#39; GOHOSTARCH=\u0026#39;amd64\u0026#39; GOHOSTOS=\u0026#39;linux\u0026#39; GOINSECURE=\u0026#39;\u0026#39; GOMODCACHE=\u0026#39;/home/user/go/pkg/mod\u0026#39; GONOPROXY=\u0026#39;\u0026#39; GONOSUMDB=\u0026#39;\u0026#39; GOOS=\u0026#39;linux\u0026#39; GOPATH=\u0026#39;/home/user/go\u0026#39; GOPRIVATE=\u0026#39;\u0026#39; GOPROXY=\u0026#39;https://proxy.golang.org,direct\u0026#39; GOROOT=\u0026#39;/usr/lib/go\u0026#39; GOSUMDB=\u0026#39;sum.golang.org\u0026#39; GOTMPDIR=\u0026#39;\u0026#39; GOTOOLCHAIN=\u0026#39;auto\u0026#39; GOTOOLDIR=\u0026#39;/usr/lib/go/pkg/tool/linux_amd64\u0026#39; GOVCS=\u0026#39;\u0026#39; GOVERSION=\u0026#39;go1.21.1\u0026#39; GCCGO=\u0026#39;gccgo\u0026#39; GOAMD64=\u0026#39;v1\u0026#39; AR=\u0026#39;ar\u0026#39; CC=\u0026#39;gcc\u0026#39; CXX=\u0026#39;g++\u0026#39; CGO_ENABLED=\u0026#39;1\u0026#39; GOMOD=\u0026#39;/dev/null\u0026#39; GOWORK=\u0026#39;\u0026#39; CGO_CFLAGS=\u0026#39;-O2 -g\u0026#39; CGO_CPPFLAGS=\u0026#39;\u0026#39; CGO_CXXFLAGS=\u0026#39;-O2 -g\u0026#39; CGO_FFLAGS=\u0026#39;-O2 -g\u0026#39; CGO_LDFLAGS=\u0026#39;-O2 -g\u0026#39; PKG_CONFIG=\u0026#39;pkg-config\u0026#39; GOGCCFLAGS=\u0026#39;-fPIC -m64 -pthread -Wl,--no-gc-sections -fmessage-length=0 -ffile-prefix-map=/tmp/go-build3927296176=/tmp/go-build -gno-record-gcc-switches\u0026#39; You can modify these using go env -w \u0026lt;VARIABLE\u0026gt; for example say, I need to change the C compiler used from gcc to clang, I can do 1 go env -w CC=\u0026#39;clang\u0026#39; When checking the go environments 1 2 $ go env | grep \u0026#39;CC=\u0026#39; CC=\u0026#39;clang\u0026#39; And reverse it back with go env -u CC\nYou can also view it as json using go env -json\nmodules and workspaces Go modules are like project files, a module is the root of all packages when you look at the GOMOD variable, you could see it contains the value /dev/null this automatically changes when there is a go.mod file in the directory used For example a directory named gostart has a go.mod file when running go env | grep 'GOMOD=' we get 1 2 $ go env | grep \u0026#39;GOMOD=\u0026#39; GOMOD=\u0026#39;/home/user/Documents/gostart/go.mod\u0026#39; Go modules represent a local project module that can be accessed when called To create a new go module, create a directory and name with your preferred name and change to that directory Run go mod init \u0026lt;module name\u0026gt; for example go mod init hello_go, the module name can be different from the directory name but it is most preferred for some cases The file created would contain the following 1 2 3 // hello_go/go.mod module hello_go go 1.21.1 Go module names are kinda unique you can even give the name of a repository link as a module name for example 1 $ go mod init github.com/Android-Jester/gostart ? So what if you want to import modules from other projects how can you do that Well the best way would be to go get \u0026lt;module link\u0026gt;, for example, I want a special way to log my files, a module I can use is github.com/sirupsen/logrus so after running go get github.com/sirupsen/logrus, the go.mod file becomes 1 2 3 4 5 6 7 8 9 // hello_go/go.mod module hello_go go 1.21.1 require ( github.com/sirupsen/logrus v1.9.3 // indirect golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8 // indirect ) Packages A package unlike a module is a subfolder and its files For every go program, the first file which contains the main function must have package main at the first line To have another package create another directory inside the project location all go files in that directory must include package \u0026lt;directory name\u0026gt; and can be called as part of the module For a project containing the following 1 2 3 4 5 . ├── common │ └── random_func.go ├── go.mod └── hello.go 1 2 3 4 5 6 7 // hello.go package main // main package must have main function import \u0026#34;hello_go/common\u0026#34; // import code from the common folder func main() { common.PrintHelloWorld() } Inside common/helloWorld.go\n1 2 3 4 5 package common // name of the directory import \u0026#34;fmt\u0026#34; func PrintHelloWorld() { fmt.Println(\u0026#34;Hello World\u0026#34;) } Here demonstrates a simple function named PrintHelloWorld, don\u0026rsquo;t worry too much about the code as it would be explained in detail later but here you could see that all go files in the directory common is taken and shown Go coding Well that is enough of the modules, let\u0026rsquo;s try to understand some go syntax\nVariables, constants and Functions Data Types The current data types of Go are bool string Signed Integers: int int8 int16 int32 int64 Unsigned Integers: uint uint8 uint16 uint32 uint64 uintptr byte (alias for uint8) rune (alias for int32, represents a Unicode code point) float: float32 float64 complex: complex64 complex128 (For complex numbers) declaration Variable Variables are declared in two ways 1 2 3 4 5 6 7 8 var helloString string helloString = \u0026#34;Hello\u0026#34; // OR var helloString string = \u0026#34;Hello\u0026#34; // OR var helloString = \u0026#34;Hello\u0026#34; // Type can be omitted // OR helloString := \u0026#34;Hello\u0026#34; The first way is using the var keyword and optionally adding the type after the name of the variable then initializing it with a value using =, you can choose to declare before initializing or initialize the variable while declaring it The second way doesn\u0026rsquo;t require the var keyword and uses this weird := to directly initialize it to the value you can actually declare multiple variables or similar type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var i,j int i,j = 1, 2 // OR var i, j int = 1, 2 // OR var i, j = 1, 2 // OR var ( i = 1 j = 2 ) // OR var ( i int = 1 j int = 2 ) // OR i, j := 1, 2 Functions Functions are declared with the func keyword, and carry arguments, the arguments can be declared with the same time and a function can return more than one value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import \u0026#34;math\u0026#34; func hypot(x float64, y float64) float64 { return math.Sqrt(x*x + y*y) } func hypot(x, y float64) float64 { return math.Sqrt(x*x + y*y) } func split(sum int) (int, int) { x := sum * 4 / 9 y := sum - x return x, y } To make the split function much simpler, you can even parse the variables directly in the declaration and learn the return expression with just return 1 2 3 4 5 func split(sum int) (x,y int) { x := sum * 4 / 9 y := sum - x return } Access Level Variables and functions in Go are private when their identifiers are in camel case and limited only to that package meaning no matter how many go files you create, those functions and variables cannot escape For example 1 2 3 4 5 6 . ├── common │ ├── priv.go │ └── random_func.go ├── go.mod └── hello.go 1 2 3 4 5 6 7 8 // hello.go package main import \u0026#34;hello_go/common\u0026#34; func main() { common.PrintHelloWorld() fmt.Println(GuessWhatNumber) common.helloGame() // this would panic } 1 2 3 4 5 6 7 8 9 // common/priv.go package common import \u0026#34;fmt\u0026#34; var GuessWhatNumber = 1.21 func helloGame() { fmt.Println(\u0026#34;HH\u0026#34;) } 1 2 3 4 5 6 7 8 // common/random_func.go package common import \u0026#34;fmt\u0026#34; func PrintHelloWorld() { helloGame() // but this would work fmt.Println(\u0026#34;Hello World\u0026#34;) } defer The defer keyword halts and stacks function calls that you want to be called last and runs that function at the end These deferred function calls can be stacked in a First In First Out way\n1 2 3 4 5 6 7 8 9 func main() { fmt.Println(\u0026#34;counting\u0026#34;) for i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } fmt.Println(\u0026#34;done\u0026#34;) } Loops and decisions For Go contains only one keyword for loops and that is for, this compared to other languages does the functionality of both for and while and this is demonstrated below\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } // While instance sum := 1 for sum \u0026lt; 1000 { sum += sum } // pre-post optional sum := 0 for ;sum \u0026lt; 10; { sum += 1 } // Forever loop sum := 0 for { sum += 1 } With [arrays and slices](#Array and Slices)(described after this section), for loops can use the range expression to loop through values in the array or slice\n1 2 3 4 5 6 7 var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} func main() { for i, v := range pow { fmt.Printf(\u0026#34;2**%d = %d\\n\u0026#34;, i, v) } } Decisions If/else If/else statements are basically the same for other languages and used to handle decisions in code 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; var x int8 = 10 if x \u0026gt; 10 { fmt.Println(x) } else if x == 10 { fmt.Println(\u0026#34;x is \u0026#34;, x) } else { fmt.Println(\u0026#34;X is less\u0026#34;) } If statements can be shorter by a line by putting the initialization of a variable inside the conditional section\n1 2 3 4 5 6 func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } return lim } Switches Switches can be used to replace the conditions of if statements and can be used relatively differently from the usual switches in other languages\nSwitches in Go, parse data top to bottom meaning that it doesn\u0026rsquo;t matter what the conditional is, either the result being checked for the value to compare against, it will always read and compare the value from the top to the bottom and compare it to whatever is provided You can also skip the conditional if you want\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // Top down parsing func main() { fmt.Println(\u0026#34;When\u0026#39;s Monday?\u0026#34;) today := time.Now().Weekday() fmt.Println(time.Now()) switch time.Tuesday { case today: fmt.Println(\u0026#34;Today.\u0026#34;) case today + 1: fmt.Println(\u0026#34;Tomorrow.\u0026#34;) case today + 2: fmt.Println(\u0026#34;In two days.\u0026#34;) default: fmt.Println(\u0026#34;Too far away.\u0026#34;) } } // Normal Switch func main() { fmt.Println(\u0026#34;What day is today?\u0026#34;) fmt.Println(time.Now()) switch today := time.Now().Weekday() { case time.Monday: fmt.Println(\u0026#34;Monday.\u0026#34;) case time.Tuesday: fmt.Println(\u0026#34;Tuesday.\u0026#34;) case time.Wednesday: fmt.Println(\u0026#34;Wednesday.\u0026#34;) default: fmt.Println(\u0026#34;Towards the end\u0026#34;) } } // No conditional func main() { t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;Good morning!\u0026#34;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026#34;Good afternoon.\u0026#34;) default: fmt.Println(\u0026#34;Good evening.\u0026#34;) } } Array and Slices Array Arrays in Go are a special datatype that holds a limited amount of data limited to a specific datatype They are declared using the [n]T where n is the length of the array and T is the type, you can access the members of an array by specifying the array identifier and their index, you can even modify each member of the array Each member corresponds to a specific memory address within the array, thus you can say Go arrays are like pointers but instead of pointing to a specific memory space, it is pointing a limited number of memory spaces 1 2 3 4 5 6 7 8 9 10 func main() { var a [2]string a[0] = \u0026#34;Hello\u0026#34; a[1] = \u0026#34;World\u0026#34; fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes) } Slice Slices on their own are almost the opposite of an array, they hold no strict length on their own but behave similar to an array They are declared similar to an array but the length isn\u0026rsquo;t included 1 2 3 4 5 6 7 8 9 func slice_trouble() { var a_slice []int describe(a_slice) a_slice = []int{1, 2, 3, 4, 5, 6, 7, 8, 9} describe(a_slice) a_slice[10] = 100 // panics describeMember(a_slice[10]) } However, the dynamic nature of slices aren\u0026rsquo;t always the case especially with the amount of memory when a slice is formed from an array or another slice, in this situation, the slice is rather a pointer pointing to the array memory space and not to a memory space holding a value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { names := [4]string{ \u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, } fmt.Println(names) // prints: [John Paul George Ringo] a := names[0:2] b := names[1:3] fmt.Println(a, b) // prints: [John Paul] [Paul George] b[0] = \u0026#34;XXX\u0026#34; fmt.Println(a, b) //prints: [John XXX] [XXX George] fmt.Println(names) // prints: [John XXX George Ringo] } Slices have both a length and a capacity.\nThe length is the number of elements it contains. The capacity is the number of elements in the underlying array, counting from the first element in the slice. The length and capacity of a slice s can be obtained using the expressions len(s) and cap(s).\nAlso slices can be created with the make() expression This also allows one to preset the length and capacity 1 b := make([]int, 0, 5) //len(b)=0 cap(b)=5 However this can change if you want to increase the length of the slice, this can be done using using the the apppend() function\n1 2 var s []int // arrays have fixed sizes, this is a slice s = append(s, 2, 3, 4) Slices can be defined in many ways depending on the amount of data that you want to carry\n1 2 3 4 5 6 7 //for the array var a [10]int // you can have a[0:10] // This takes between 0 and 10 a[:10] // this takes from 9 backwards a[0:] // this takes from the index 0 to the end a[:] // this just takes all Structs and Interfaces and Maps Structs Structs are like a type system that are used to contain a set of data and also can contain their own functions, in Go, they are defined using the type keyword\n1 2 3 4 type MyStruct struct { structValue string anyVariable string } However you can initialize a struct in many ways as well, for example\n1 2 3 4 5 6 7 8 9 10 type Vertex struct { X,Y int } var ( v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 p = \u0026amp;Vertex{1, 2} // has type *Vertex ) Here, we can see that the vertex struct can be initialized with both or one of the values, without any value or as a pointer\nFunctions that require a struct are called methods and they are defined using pointers to a struct and have a special syntax for that\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import \u0026#34;fmt\u0026#34; type MyStruct struct { structValue string anyVariable string } // Methods func (st MyStruct) NewStruct() MyStruct { st.structValue = \u0026#34;[+] Structure Value\u0026#34; st.anyVariable = \u0026#34;[+] ANy\u0026#34; return st } // Same but with pointers func (st *MyStruct) Initial() { st.structValue = \u0026#34;Structure Value\u0026#34; st.anyVariable = \u0026#34;ANy\u0026#34; } func main() { var newStruct MyStruct = MyStruct{\u0026#34;Hello\u0026#34;, \u0026#34;Hi\u0026#34;} fmt.Println(newStruct) // prints: {Hello Hi} newStruct.Initial()\tfmt.Println(newStruct) // prints: {Structure Value ANy} newStruct.NewStruct() fmt.Println(newStruct)\t// prints: {Structure Value ANy} } In this example, methods are created from the struct MyStruct, but if you look closely, they don\u0026rsquo;t behave the same, the initial() method behaves like a method you would find in Java or C# but the NewStruct() method doesn\u0026rsquo;t, it doesn\u0026rsquo;t have a pointer reference and thus only takes the value of the struct but doesn\u0026rsquo;t update the value but rather just takes data from that struct as if another struct has been created\nInterfaces Interfaces are basically a set of method signatures that are defines the structs that implement them, they work similarly to implementation of interfaces in some languages like C# or JAVA but differ since they act as place holders for struct values that implement their methods The value of an interface type can hold any value that implements those methods\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Abser interface { Abs() float64 } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { var a Abser v := Vertex{3, 4} a = \u0026amp;v // a *Vertex implements Abser // a = v panics because, v is a Vertex (not *Vertex) and does NOT implement Abser. fmt.Println(a.Abs()) } Empty Interface Interface can be made without any value and they can hold any value of any type it is instantiated with\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { var i interface{} describe(i) i = 42 describe(i) i = \u0026#34;hello\u0026#34; describe(i) } func describe(i interface{}) { fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } Type assertion A type assertion provides access to an interface value\u0026rsquo;s underlying concrete value, it is done using t = i.(\u0026lt;Type\u0026gt;) or t, ok := i.(\u0026lt;Type\u0026gt;)\nThis statement asserts that the interface value i holds the concrete type T and assigns the underlying T value to the variable t. When using the expression t, ok := i.(T), ok is a bool, that checks if the type the interface has is correct 1 2 3 4 5 6 7 8 9 10 func main() { var i interface{} i = \u0026#34;Hello\u0026#34; t := i.(string) fmt.Println(t) // this prints Hello t2, ok := i.(float64) if ok { fmt.Print(t2) } } Switches can be used to check if the interface is of the type provided by the cases 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 func do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(\u0026#34;Twice %v is %v\\n\u0026#34;, v, v*2) case string: fmt.Printf(\u0026#34;%q is %v bytes long\\n\u0026#34;, v, len(v)) default: fmt.Printf(\u0026#34;I don\u0026#39;t know about type %T!\\n\u0026#34;, v) } } func main() { do(21) do(\u0026#34;hello\u0026#34;) do(true) } ``` ### Maps - Maps are like hash-maps, they contain a key and value pair, they are defined using the expression `map[T1]T2`, where T1 is the type that acts as a key and T2 represents the value, you can create a map using the `make()` expression similar to how slices are created - Maps like slices don\u0026#39;t have a defined length thus you can continuously make key-value pairs in a already instantciated map ```go type Vertex struct { Lat, Long float64 } var m map[string]Vertex func main() { m = make(map[string]Vertex) m[\u0026#34;Bell Labs\u0026#34;] = Vertex{ 40.68433, -74.39967, } m[\u0026#34;Bell Labs2\u0026#34;] = Vertex{ 40.68433, -74.39, } fmt.Println(m[\u0026#34;BellLabs2\u0026#34;]) } ``` - You can delete a map using the `delete()` expression ```go delete(m, \u0026#34;Bell Labs\u0026#34;) Null references When a variable isn\u0026rsquo;t instantiated it contains a null value Null values are represented by the zeros or nil of their types\n0 for numeric types, false for the boolean type, and \u0026quot;\u0026quot; (the empty string) for strings. nil is returned from others such as structs and interfaces Error Interfaces This is a built interface that is used to handle errors Error methods can be used to handle situations were an error would exist Errors can be using a simple if expression 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type MyError struct { When time.Time What string } func (e *MyError) Error() string { return fmt.Sprintf(\u0026#34;at %v, %s\u0026#34;, e.When, e.What) } func run() error { return \u0026amp;MyError{ time.Now(), \u0026#34;it didn\u0026#39;t work\u0026#34;, } } func main() { if err := run(); err != nil { fmt.Println(err) } } I hope this little Go language tour helps a lot for those who are either starting to code or who just want to learn a little about the language, although there is a much more detailed one at the Go Language Tour if there is any problem, you can contact me here and I would make the necessary changes and fixes to this blog With that said, thank you for reading\n","date":"2023-09-07T22:20:32Z","permalink":"https://androidjester.github.io/p/go-starter/","title":"Go Starter"},{"content":"As Visual Studio Code is one of the most used code editor, beginner in C and C++ programming have difficulty setting up this editor for C and C++ programming\nHere I would like to help by setting up VSCode with Clangd\nClangd is an LSP that helps coding in C or C++ a easier\nWe would be setting up our C project for writing a simple window using the GTK libraries\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // main.c #include \u0026lt;gtk/gtk.h\u0026gt; static void activate(GtkApplication *app, gpointer user_data) { GtkWidget *window; GtkWidget *label; window = gtk_application_window_new(app); label = gtk_label_new(\u0026#34;Hello GNOME!\u0026#34;); gtk_container_add(GTK_CONTAINER(window), label); gtk_window_set_title(GTK_WINDOW(window), \u0026#34;Welcome to GNOME\u0026#34;); gtk_window_set_default_size(GTK_WINDOW(window), 400, 200); gtk_widget_show_all(window); } int main(int argc, char **argv) { GtkApplication *app; int status; app = gtk_application_new(NULL, G_APPLICATION_FLAGS_NONE); g_signal_connect(app, \u0026#34;activate\u0026#34;, G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), argc, argv); g_object_unref(app); return status; } This code is from the mesonbuild #site which is the build system we would be using for the project\nWhat is an LSP? An LSP(Language Server Protocol) is a program that looks through your code for syntax errors and in some cases linting errors depending on the linter provided\nClangd Setup on VSCode First we would need the Clangd extension as well as the LSP itself You can download the extension from #here The extension provides its own Clangd LSP but in case of issues with that we would like to download and setup the clangd package from the official site for both Windows and Linux\nLinux Setup We can download and install the clangd LSP using the available package manager and installer like apt for Debian/Ubuntu, dnf or yum for Red Hat distributions and pacman or yay for Arch\nI use Arch so the command I am more familar with is yay 1 yay -S clangd-opt # This downloads and builds the latest clangd available from the Arch User Repository Then inside our VSCode settings we set path to where our clangd would be located We try to find the path to clangd using whereis clangd or which clangd Building the project Clangd would work for most cases however when involving non-standard libraries like our GTK library, we would start to see a lot of errors First we need to know if the library\u0026rsquo;s files are available, we can download them and include them to our project but to make this short we would just use pkg-config and grep command to find the necessary GTK+ library for our little demo which I have installed in my system Then we would include this as a dependency to our project through our build tool such as make, CMake or Meson, we would be using meson which is simpler and easy to use.\nSo we install meson using our package manager\n1 sudo pacman -S meson We setup our meson.build with the project, this lays out the project for compilation\nWe write the following code for our demo\u0026rsquo;s meson.build\n1 2 3 project(\u0026#39;demo\u0026#39;, \u0026#39;c\u0026#39;) gtk = dependency(\u0026#39;gtk+-3.0\u0026#39;) executable(\u0026#39;demo\u0026#39; \u0026#39;main.c\u0026#39;, dependencies: [gtk]) What our meson.build file will tell the build system is that our project name is demo and it uses the C programming language we have included the gtk+-3.0 as a dependency and we would build an executable with the name demo from our main.c file\nThis generates the necessary files and parameters for our compilation\nA json file with that name compile_commands.json is generated and allows us to quickly use our build system to compile our code, this is also needed by clangd to know our dependency files\nIn our project directory, we setup our build folder using meson but we would need our compile_commands.json to be within the root of the project for clangd to work properly with so we download bear for that purpose and use it along meson to get our compile_commands.json\n1 2 sudo pacman -S bear bear -- meson setup build With that done our compile_commands.json would contain the following code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [ { \u0026#34;arguments\u0026#34;: [ \u0026#34;/usr/bin/cc\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;-D_FILE_OFFSET_BITS=64\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;sanitycheckc.exe\u0026#34;, \u0026#34;sanitycheckc.c\u0026#34; ], \u0026#34;directory\u0026#34;: \u0026#34;/home/android-jester/Documents/learning-concepts/c/demo/build/meson-private\u0026#34;, \u0026#34;file\u0026#34;: \u0026#34;/home/android-jester/Documents/learning-concepts/c/demo/build/meson-private/sanitycheckc.c\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;/home/android-jester/Documents/learning-concepts/c/demo/build/meson-private/sanitycheckc.exe\u0026#34; } ] This however doesn\u0026rsquo;t contain the include files for that we need to compile our project using meson\n1 bear -- meson compile -C build Funny to say there is some depreciated code in the source file but it will work out\nWith that done our compile_commands.json look like this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 [ { \u0026#34;arguments\u0026#34;: [ \u0026#34;/usr/bin/cc\u0026#34;, \u0026#34;-Idemo.p\u0026#34;, \u0026#34;-I.\u0026#34;, \u0026#34;-I..\u0026#34;, \u0026#34;-I/usr/include/gtk-3.0\u0026#34;, \u0026#34;-I/usr/include/pango-1.0\u0026#34;, \u0026#34;-I/usr/include/glib-2.0\u0026#34;, \u0026#34;-I/usr/lib/glib-2.0/include\u0026#34;, \u0026#34;-I/usr/include/sysprof-4\u0026#34;, \u0026#34;-I/usr/include/harfbuzz\u0026#34;, \u0026#34;-I/usr/include/freetype2\u0026#34;, \u0026#34;-I/usr/include/libpng16\u0026#34;, \u0026#34;-I/usr/include/libmount\u0026#34;, \u0026#34;-I/usr/include/blkid\u0026#34;, \u0026#34;-I/usr/include/fribidi\u0026#34;, \u0026#34;-I/usr/include/cairo\u0026#34;, \u0026#34;-I/usr/include/pixman-1\u0026#34;, \u0026#34;-I/usr/include/gdk-pixbuf-2.0\u0026#34;, \u0026#34;-I/usr/include/gio-unix-2.0\u0026#34;, \u0026#34;-I/usr/include/cloudproviders\u0026#34;, \u0026#34;-I/usr/include/atk-1.0\u0026#34;, \u0026#34;-I/usr/include/at-spi2-atk/2.0\u0026#34;, \u0026#34;-I/usr/include/at-spi-2.0\u0026#34;, \u0026#34;-I/usr/include/dbus-1.0\u0026#34;, \u0026#34;-I/usr/lib/dbus-1.0/include\u0026#34;, \u0026#34;-fdiagnostics-color=always\u0026#34;, \u0026#34;-D_FILE_OFFSET_BITS=64\u0026#34;, \u0026#34;-Wall\u0026#34;, \u0026#34;-Winvalid-pch\u0026#34;, \u0026#34;-O0\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;-pthread\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;demo.p/main.c.o\u0026#34;, \u0026#34;../main.c\u0026#34; ], \u0026#34;directory\u0026#34;: \u0026#34;/home/android-jester/Documents/learning-concepts/c/demo/build\u0026#34;, \u0026#34;file\u0026#34;: \u0026#34;/home/android-jester/Documents/learning-concepts/c/demo/main.c\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;/home/android-jester/Documents/learning-concepts/c/demo/build/demo.p/main.c.o\u0026#34; } ] This shows how my code with compile using the gcc compiler installed on my system, I can change anything in this file manually but more importantly we need to see if the clangd extension has recognized our header files\nAs we can see the error lines are gone and we can run our executable in the build folder\n1 ./build/demo Windows Setup MSYS2 MINGW On Windows, we would use MSYS2 MINGW to setup our environment by installing the GNU GCC compiler and Meson build tool\nWe can download MSYS2 installer from here\nAfter going through the installation process, we would have the mingw64 msys2 terminal available.\nClangd Installation Afterward install clangd from the clang-tools-extra inside bash from mingw64\n1 pacman -S mingw-w64-x86_64-clang-tools-extra The tools are a lot bigger on the Windows side because it also contains the needed gcc compiler and libraries, Clang compiler and libraries and other tools\nWith that we can find the clangd using whereis clangd VSCode setup In VSCode, after installing the clangd extension, we can either use the bundled clangd downloaded from the extension or we can link it to our clangd installed from msys2 mingw64\nIn VSCode, we can add the following in our user\u0026rsquo;s settings.json which contains all our user settings.\n1 2 3 4 5 6 7 8 9 \u0026#34;terminal.integrated.profiles.windows\u0026#34;: { \u0026#34;MSYS2\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;/c\u0026#34;, \u0026#34;C:\\\\msys64\\\\msys2_shell.cmd -defterm -here -no-start -mingw64 -use-full-path\u0026#34; ] }, ... Conan and Code Before we start to code we would need to easily download and use some external libraries Using the guide from Conan, C++ Open Source Package Manager, We can setup conan for msys2 mingw-w64\nWith conan executable setup we need to create our conanfile.txt for our project\n1 2 3 4 5 6 [requires] zlib/1.2.13 [generators] PkgConfigDeps MesonToolchain We are simply importing zlib from the conan package center where we can download the needed libraries and generate a native file for our meson\nFor Windows GTK doesn\u0026rsquo;t work as expected thus we would go for a command line compression tool zlib so inside our meson.build file we include the following\n1 2 3 project(\u0026#39;demo\u0026#39;, \u0026#39;c\u0026#39;) zlib = dependency(\u0026#39;zlib\u0026#39;) executable(\u0026#39;demo\u0026#39;, \u0026#39;main.c\u0026#39;, dependencies: [zlib]) And in our project contains our code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //main.c #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;zlib.h\u0026gt; int main(void) { char buffer_in [256] = {\u0026#34;A simple string we want to compress, don\u0026#39;t worry about the detail just let the library do its thing we will also try to print out the version of ZLIB to show that it works\u0026#34;}; char buffer_out [256] = {0}; // Just deflation or compression z_stream defstream; defstream.zalloc = Z_NULL; defstream.zfree = Z_NULL; defstream.opaque = Z_NULL; defstream.avail_in = (uInt) strlen(buffer_in); defstream.next_in = (Bytef *) buffer_in; defstream.avail_out = (uInt) sizeof(buffer_out); defstream.next_out = (Bytef *) buffer_out; deflateInit(\u0026amp;defstream, Z_BEST_COMPRESSION); deflate(\u0026amp;defstream, Z_FINISH); deflateEnd(\u0026amp;defstream); // Printing out the compression details printf(\u0026#34;Uncompressed size is: %lu\\n\u0026#34;, strlen(buffer_in)); printf(\u0026#34;Compressed size is: %lu\\n\u0026#34;, strlen(buffer_out)); printf(\u0026#34;ZLIB VERSION: %s\\n\u0026#34;, zlibVersion()); return EXIT_SUCCESS; } Build and compile Bear is the program we used in linux to copy our compile_commands.json from our build folder however I cannot easily find a prebuilt executable for Windows thus we would manually copy the compile_commands.json from the build folder\nFirst we setup the build by getting our dependencies\n1 conan install . --output-folder=build --build=missing This generates a build folder which contains the files necessary to build our project using meson\nWe use meson and the native meson file generated from the build folder conan generated to create our own build folder\n1 meson setup \u0026lt;build-folder-name\u0026gt; --native-file build/conan_meson_native.ini However you might approach an error like this\nWe can fix that error by simply changing the compiler used to use our gcc compiler included in out clang-tools-extra in our build/conan_meson_native.ini\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 [properties] [constants] preprocessor_definitions = [] # Constants to be overridden by conan_meson_deps_flags.ini (if exists) deps_c_args = [] deps_c_link_args = [] deps_cpp_args = [] deps_cpp_link_args = [] [project options] wrap_mode = \u0026#39;nofallback\u0026#39; bindir = \u0026#39;bin\u0026#39; sbindir = \u0026#39;bin\u0026#39; libexecdir = \u0026#39;bin\u0026#39; includedir = \u0026#39;include\u0026#39; libdir = \u0026#39;lib\u0026#39; [binaries] # c = \u0026#39;cl\u0026#39; # cpp = \u0026#39;cl\u0026#39; # The compiler binary names c = \u0026#39;gcc\u0026#39; cpp = \u0026#39;gcc\u0026#39; [built-in options] buildtype = \u0026#39;release\u0026#39; b_vscrt = \u0026#39;md\u0026#39; b_ndebug = \u0026#39;true\u0026#39; cpp_std = \u0026#39;vc++14\u0026#39; backend = \u0026#39;ninja\u0026#39; pkg_config_path = \u0026#39;C:\\Users\\Android-Jester\\Documents\\learning-concepts\\C\\demo\\build\u0026#39; # C/C++ arguments c_args = [] + preprocessor_definitions + deps_c_args c_link_args = [] + deps_c_link_args cpp_args = [] + preprocessor_definitions + deps_cpp_args cpp_link_args = [] + deps_cpp_link_args Finally our build would be completed The compile_commands.json file which clangd needs is inside the builddir so we can easily copy it to the root directory, it might contains the following\n1 2 3 4 5 6 7 8 [ { \u0026#34;directory\u0026#34;: \u0026#34;/c/Users/Android-Jester/Documents/learning-concepts/C/demo/builddir\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;\\\u0026#34;gcc\\\u0026#34; \\\u0026#34;-Idemo.exe.p\\\u0026#34; \\\u0026#34;-I.\\\u0026#34; \\\u0026#34;-I..\\\u0026#34; \\\u0026#34;-fdiagnostics-color=always\\\u0026#34; \\\u0026#34;-DNDEBUG\\\u0026#34; \\\u0026#34;-D_FILE_OFFSET_BITS=64\\\u0026#34; \\\u0026#34;-Wall\\\u0026#34; \\\u0026#34;-Winvalid-pch\\\u0026#34; \\\u0026#34;-O3\\\u0026#34; -MD -MQ demo.exe.p/main.c.obj -MF \\\u0026#34;demo.exe.p\\\\main.c.obj.d\\\u0026#34; -o demo.exe.p/main.c.obj \\\u0026#34;-c\\\u0026#34; ../main.c\u0026#34;, \u0026#34;file\u0026#34;: \u0026#34;../main.c\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;demo.exe.p/main.c.obj\u0026#34; } ] This includes all the library files needed thus we can compile our code and run it to see the result\n1 meson compile -C \u0026lt;build-folder-name\u0026gt; And VSCode can recognize our zlib header file I hope this was a short and informative guide as this is my first post, please if there are any issues or suggestions for improvements with the process, please let me know in the comments\n","date":"2023-09-07T22:20:32Z","permalink":"https://androidjester.github.io/p/vscode-setup-guide-for-c-and-c/","title":"VSCode Setup Guide for C and C++"}]